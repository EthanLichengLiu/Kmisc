<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Introduction to Kmisc}
\usepackage[utf8]{inputenc}
-->

<style>
body {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
}

table, th, td {
  
  font-size: 14px;
  font-family: "Droid Sans Mono", "DejaVu Sans MS", "Consolas", "Lucida Console", sans-serif;
  text-align: right;
  
}

table {
  border-collapse: collapse;
  margin-left: auto;
  margin-right: auto;
  page-break-inside: avoid;
}

th, td {
  border: 1px solid #9AD;  
  background-color: #FFFFFF;
}

tr {
  page-break-inside: avoid;
  page-break-after: auto;
}

tr:nth-child(odd) td {
  background-color: #FCFCFE;
}

tr:nth-child(even) td {
  background-color: #F4F4FF;
}

.twoDtable tr:nth-last-child(1) td, th {
  font-weight: bold;
  text-align: center;
  background-color: #FBFBFB;
}

tr:nth-child(1) {
  font-weight: bold;
  background-color: #FBFBFB;
}

tr:nth-child(1) td, th {
  text-align: center;
}

/* R-outputted 2x2 tables */

.twoDtable tr:nth-child(2) td {
  font-weight: bold;
  text-align: center;
}

.twoDtable tr:nth-last-child(1) {
  border-top: 2px solid black;
}

.twoDtable tr:nth-child(3) td:nth-child(2) {
  font-weight: bold;
  text-align: center;
}

.twoDtable tr td:nth-last-child(1) {
  border-left: 2px solid black;
  text-align: center;
  font-weight: bold;
}

.twoDtable tr td:nth-child(1) {
  font-weight: bold;
  text-align: center;
}

/* End 2x2 tables */

/* 1D tables */

.oneDtable tr:nth-last-child(1) td {
  border-top: 2px solid black;
  font-weight: bold;
}

/* End 1D tables */

p {
  font-family: 'Proxima Nova', sans-serif;
  font-size: 14px;
  line-height:125%;
}

p.question {
  font-size: 14px;
  font-weight: bold;
  display: block;
  color: red;
}

p.mono {
  font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

ul, ol {
  font-family: 'Proxima Nova', sans-serif;
  font-size: 14px;
}

.divTable {
  display: inline-block;
  width:auto;
  padding:5px;
  border-style:solid;
  border-width:thin;
  border-radius:10px;
}

.divTable hr {
  height: 1px;
  border: 0;
  width: 100%;
}

.divTable .left {
  margin-left:10px;
  float:left;
}

.divTable .right {
  margin-left:200px;
  margin-right:10px;
}



img.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.center {
  margin-left: auto;
  margin-right: auto;
  display: block;
  
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
   padding: 5px;
}

h1, h2, h3, h4, h5, h6 {
  font-family: "Helvetica", sans-serif;  
}

h1 { 
   font-size:2.6em;
}

h2 { 
   font-size:2.2em;
}

h3 { 
   font-size:1.8em; 
}

h4 { 
   font-size:1.4em; 
}

h5 { 
   font-size:1.0em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {  
   margin-top: 0;
   border: 1px solid #ccc;
}

pre code {
   display: block; 
   padding: 0.5em;
   white-space: pre-wrap;
}

code.r {
   background-color: #F8F8F8;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
  
  body { 
    /* font-size:12pt; */ 
    max-width:100%; 
    border: none;
    padding: none;
  }
     
  a, a:visited { 
    text-decoration: underline;
  }

  hr { 
    visibility: hidden;
    page-break-before: always;
  }

  pre, blockquote {
    display: block;
    margin-left: auto;
    margin-right: auto;
    font-size:8pt;
    padding-right: 1em; 
    page-break-inside: avoid;
  }
   
  table {
	  page-break-inside: avoid;
	}
  
  td {
    -webkit-print-color-adjust: exact;
    font-size: 12px;
  }

  tr, img { 
    page-break-inside: avoid; 
  }

  @page {
    size: auto;
    margin-left: 1in;
    margin-right: 1in;
  }
  
  p { 
    orphans: 3; 
    widows: 3; 
  }
   
  h2 {
    page-break-before: always;
  }
   
  h1, h2, h3 { 
    font-family: serif;
    page-break-after: avoid; 
  }
}
</style>

<link rel="stylesheet" href="markdown.css">

Quick Introduction to Kmisc
=====

Kmisc introduces a bunch of utility functions to make the R coding experience
a bit easier. Some of the most useful functions in the package are shown here.

```{r, tidy=FALSE}
set.seed(123)
library(Kmisc)
library(lattice)
library(grid)
dat <- data.frame( x=letters[1:4], y=1:4, z=LETTERS[1:4] )
```

`without`: This function is used to remove columns from a `list` / `data.frame`.

```{r, tidy=FALSE}
## let's remove columns 'x' and 'z' from dat.
dat[ !(names(dat) %in% c('x', 'z')) ]
## I always find that syntax awkward. Let's use Kmisc::without instead.
without( dat, x, z )
## finally, we can also index by $ (note: NOT done by partial matching):
without( dat, dat$x, dat$z )
## this could be handy for vectors with very long names, if using an IDE with
## auto-complete
```

`extract`: Extract vectors from a data.frame or list. Although there is already
a good subsetting syntax for lists and vectors, I wanted a complementary
function for `without`.

```{r tidy=FALSE}
extract( dat, x, y)
```

`without.re, extract.re`: Extract variables whose names don't match / do match
a regular expression pattern.
```{r tidy=FALSE}
extract.re( dat, "[xy]")
without.re( dat, "[xy]")
```

`swap`: Replace elements in a vector.

```{r tidy=FALSE}
tDat <- dat ## make a temporary copy of dat

## Replace some elements in tDat$y
tDat$y <- swap( tDat$y, from=c(2, 4), to=c(20, 40) )
cbind( dat$y, tDat$y )
```

`factor_to_char`, `char_to_factor`: A set of functions that recurse through
a list / data.frame and set all elements that are characters to factors,
and vice versa.

```{r tidy=FALSE}
bDat <- data.frame( x=rnorm(10), y=sample(letters,10), z=sample(letters,10) )
str( bDat )
str( factor_to_char(bDat) )
```

`dapply`: The `data.frame` version of the `l/sapply` series of functions.

Why have this function when `sapply` still does much the same? I always get
frustrated with the fact that either an `array` or a `list` is returned
by sapply, but never a `data.frame`.

```{r, tidy=FALSE}
dat <- data.frame( x = rnorm(100), y = rnorm(100), z = rnorm(100) )
dapply( dat, summary )
```

`kMerge`: Left joins, aka. `merge( all.x=TRUE, ... )` without any mangling 
of the order.

```{r, tidy=FALSE}
dat1 <- data.frame( id=5:1, x=c("a","a","b","b","b"), y=rnorm(5) )
dat2 <- data.frame( id=c(1, 2, 4), z=rnorm(3) )

## default merge changes id order
merge( dat1, dat2, by="id", all.x=TRUE )
## even the sort parameter can't save you
merge( dat1, dat2, by="id", all.x=TRUE, sort=TRUE )
# kMerge keeps it as is
kMerge( dat1, dat2, by="id" )
```

`in_interval`: A fast C implementation for determing which elements of a 
vector `x` lie within an interval `[lo, hi)`.

```{r tidy=FALSE}
x <- runif(10)*10; lo <- 5; hi <- 10
print( data.frame( x=x, between_5_and_10=in_interval(x, lo, hi) ) )
```

`stack_list`: Use this to stack data.frames in a list. This can be useful if
e.g. you've run some kind of bootstrap procedure and have all your results
stored in as a list of data.frames -- even `do.call( rbind, dfs )` can be slow.
The difference is even more prominent when used on very large lists.

This is partially deprecated by `data.table::rbindlist` now, which has a much faster C implementation.

```{r tidy=FALSE}
dfs <- replicate(1E3, 
                 data.frame(x=rnorm(10), y=sample(letters,10), z=sample(LETTERS,10)),
                 simplify=FALSE
                 )
str( stack_list(dfs) )
system.time( stack_list(dfs) )
system.time( do.call(rbind, dfs) )
```

Fast String Operations
-----

For whatever reason, R is missing some nice builtin 'string' functions. I've
introduced a few functions, implemented in C for speed, for two common
string operations.

`str_rev`: Reverses a character vector; ie, a vector of strings.
`str_rev2` is there if you need to reverse a potentially unicode string.

```{r tidy=FALSE}
str_rev( c("ABC", "DEF", NA, paste(LETTERS, collapse="") ) )
str_rev2( c("はひふへほ", "abcdef") )
```

`str_slice`: Slices a vector of strings at consecutive indices `n`.
`str_slice2` exists for potentially unicode strings.
```{r tidy=FALSE}
str_slice( c("ABCDEF", "GHIJKL", "MNOP", "QR"), 2 )
str_slice2( "ハッピー", 2 )
```

`str_sort`: sort a string.
```{r, tidy=FALSE}
str_sort("asnoighewgypfuiweb")
```

File I/O
-----

Sometimes, you get really large data files that just aren't going to fit into
RAM. You really wish you could split them up in a structured way, transform
them in some way, and then put them back together. One might consider a more
'enterprise' edition of the split-apply-combine framework (Hadoop and friends),
but the alternative is to use C++ to munge through a text file and pull out
things that we actually want.

`split_file`: This function splits a delimited file into multiple files, according to
unique entries in a chosen column.

`extract_rows_from_file`: From a delimited text file, extract only the rows for
which the entries in a particular column match some set of items that you
wish to keep.

C++ Function Generators
-----

These functions wrap around generated source code to produce useful, fast
functions very quickly.

`Rcpp_tapply_generator`: See the example.
```{r, tidy=FALSE}
dat <- data.frame( y=rnorm(100), x=sample(letters[1:5], 100, TRUE) )
tMean <- Rcpp_tapply_generator("return mean(x);")
with( dat, tMean(y, x) )
with( dat, tapply(y, x, mean) )
```

`Rcpp_apply_generator`: An apply function generator tailored to 2D matrices.
```{r, tidy=FALSE}
aMean <- Rcpp_apply_generator("return mean(x);")
mat <- matrix( rnorm(100), nrow=10 )
aMean(mat, 2)
apply(mat, 2, mean)
```

Faster Common Operations through C and C++
-----

`tapply_`: This function operates like `tapply` but works faster through a 
faster factor generating function, as well as an optimized split. Note that
it is however restricted to the (common) case of your value and grouping
variables being column vectors.
```{r, tidy=FALSE}
library(microbenchmark)
y <- rnorm(1000); x <- sample(letters[1:5], 1000, TRUE)
tapply(y, x, mean)
tapply_(y, x, mean)
microbenchmark(
  tapply(y, x, mean),
  tapply_(y, x, mean),
  tMean(y, x)
  )
```

`melt_`: This function operates like `reshape2:::melt`, but works almost
entirely through C and hence is much faster. However, the implementation is
currently less flexible, and only operates on `data.frame`s and `matrix`s.
```{r, tidy=FALSE}
dat <- data.frame(
  id=LETTERS[1:5],
  x1=rnorm(5),
  x2=rnorm(5),
  x3=rnorm(5)
)
print(dat)
melt_(dat, id.vars="id")
```
The cool R Markdown / HTML Stuff
-----

Next, a set of helper HTML generating functions.
I've found them especially useful in laying out R Markdown documents,
and also controlling more finely CSS styling and such.

`makeHTMLTable`: Converts a `data.frame` or `matrix` into an HTML table.
Best seen with an example. Note that we require `results='asis'` in the chunk
options.

```{r results='asis'}
dat <- data.frame( apple=c('a', 'b', 'c'), banana=c(1, 2, 3) )
makeHTMLTable( dat, use.col.names=TRUE )
```

`kTable`: Generated 1D and 2D (contingency) tables, which are then typically
passed through `makeHTMLtable` for 1D tables, or `pxt` for 2D tables.

```{r results='asis', tidy=FALSE}
x <- factor( rbinom(100, 2, 0.2) )
y <- factor( rbinom(100, 3, 0.3) )

p1t( kTable( x, top.left.cell="foo" ) )
pxt( kTable(x, y, 
            top.left.cell="foo", 
            top.label="bar", 
            left.label="baz" 
            ) )

```

`html`: Custom HTML in an R Markdown document.

```{r results='asis', tidy=FALSE}
html(
     table( class="my-favourite-table",
            tr(
              td("Apples"),
              td("Bananas")
              ),
            tr(
              td("20"),
              td("30")
              )
            )
     )
```